// Generated by CoffeeScript 1.6.3
(function() {
  define(function(require, exports, module) {
    var Asteroid, bounce, collisionCheck, damping, exp, resolveCollisions, updateBodies;
    exp = {};
    damping = 0.95;
    Asteroid = (function() {
      function Asteroid(px, py, vx, vy, r, m, ori, rot) {
        this.px = px != null ? px : 0;
        this.py = py != null ? py : 0;
        this.vx = vx != null ? vx : 0;
        this.vy = vy != null ? vy : 0;
        this.r = r != null ? r : 0;
        this.m = m != null ? m : 0;
        this.ori = ori != null ? ori : 0;
        this.rot = rot != null ? rot : 0;
      }

      return Asteroid;

    })();
    exp.updateModel = function(model, dt) {
      var list;
      list = model.players.concat(model.asteroids);
      updateBodies(list, dt);
      resolveCollisions(list);
      return model;
    };
    exp.renderModel = function(c, model) {
      var ast, _i, _len, _ref, _results;
      _ref = model.asteroids;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ast = _ref[_i];
        c.fillStyle = "red";
        c.beginPath();
        c.arc(ast.px, ast.py, ast.r, 0, Math.PI * 2, true);
        c.closePath();
        _results.push(c.fill());
      }
      return _results;
    };
    exp.addRandomAsteroid = function(model) {
      var newAst;
      newAst = new Asteroid(100 + Math.random() * 200, 200 + Math.random() * 200, 200 - Math.random() * 400, 200 - Math.random() * 400, 5 + Math.random() * 35, 50 + Math.random() * 100);
      return model.asteroids.push(newAst);
    };
    updateBodies = function(list, dt) {
      var body, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        body = list[_i];
        body.px += body.vx * dt;
        body.py += body.vy * dt;
        _results.push(body.ori += body.rot * dt);
      }
      return _results;
    };
    resolveCollisions = function(list) {
      var b1, b2, _i, _ref, _results;
      _results = [];
      for (b1 = _i = 0, _ref = list.length; 0 <= _ref ? _i < _ref : _i > _ref; b1 = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _ref2, _results1;
          _results1 = [];
          for (b2 = _j = _ref1 = b1 + 1, _ref2 = list.length; _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; b2 = _ref1 <= _ref2 ? ++_j : --_j) {
            _results1.push(collisionCheck(list[b1], list[b2]));
          }
          return _results1;
        })());
      }
      return _results;
    };
    collisionCheck = function(body1, body2) {
      var dist;
      dist = Math.sqrt((body1.px - body2.px) * (body1.px - body2.px) + (body1.py - body2.py) * (body1.py - body2.py));
      if (dist < (body1.r + body2.r)) {
        return bounce(body1, body2, dist, damping);
      }
    };
    bounce = function(body1, body2, dist, damping) {
      var ang, dir1, dir2, dx, dy, fSx1, fSx2, fSy1, fSy2, gap, gapX, gapY, mag1, mag2, massSum, nSx1, nSx2, nSy1, nSy2;
      if (damping == null) {
        damping = 1;
      }
      dx = body1.px - body2.px;
      dy = body1.py - body2.py;
      ang = Math.atan2(dy, dx);
      mag1 = Math.sqrt(body1.vx * body1.vx + body1.vy * body1.vy);
      mag2 = Math.sqrt(body2.vx * body2.vx + body2.vy * body2.vy);
      dir1 = Math.atan2(body1.vy, body1.vx);
      dir2 = Math.atan2(body2.vy, body2.vx);
      nSx1 = mag1 * Math.cos(dir1 - ang);
      nSy1 = mag1 * Math.sin(dir1 - ang);
      nSx2 = mag2 * Math.cos(dir2 - ang);
      nSy2 = mag2 * Math.sin(dir2 - ang);
      fSx1 = ((body1.m - body2.m) * nSx1 + (body2.m + body2.m) * nSx2) / (body1.m + body2.m);
      fSx2 = ((body1.m + body1.m) * nSx1 + (body2.m - body1.m) * nSx2) / (body1.m + body2.m);
      fSy1 = nSy1;
      fSy2 = nSy2;
      body1.vx = Math.cos(ang) * fSx1 + Math.cos(ang + Math.PI / 2) * fSy1;
      body1.vy = Math.sin(ang) * fSx1 + Math.sin(ang + Math.PI / 2) * fSy1;
      body2.vx = Math.cos(ang) * fSx2 + Math.cos(ang + Math.PI / 2) * fSy2;
      body2.vy = Math.sin(ang) * fSx2 + Math.sin(ang + Math.PI / 2) * fSy2;
      if (damping !== 1) {
        body1.vx *= damping;
        body1.vy *= damping;
        body2.vx *= damping;
        body2.vy *= damping;
      }
      gap = body1.r + body2.r - dist;
      gapX = gap * Math.cos(ang);
      gapY = gap * Math.sin(ang);
      massSum = body1.m + body2.m;
      body1.px += gapX * body1.m / massSum;
      body1.py += gapY * body1.m / massSum;
      body2.px -= gapX * body2.m / massSum;
      return body2.py -= gapY * body2.m / massSum;
    };
    return exp;
  });

}).call(this);
