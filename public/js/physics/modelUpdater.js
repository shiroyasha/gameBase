// Generated by CoffeeScript 1.6.3
(function() {
  define(function(require, exports, module) {
    var AsteroidHandler, bounce, collisionCheck, damping, exp, resolveCollisions, updateBodies;
    exp = {};
    damping = 0.95;
    AsteroidHandler = require('physics/AsteroidHandler');
    exp.updateModel = function(model, dt) {
      var list;
      list = model.asteroids.concat(model.me);
      updateBodies(list, dt);
      AsteroidHandler.updateAsteroids(model);
      resolveCollisions(list);
      return model;
    };
    exp.renderModel = function(c, model) {
      var ast, _i, _len, _ref, _results;
      _ref = model.asteroids;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ast = _ref[_i];
        c.fillStyle = "red";
        c.beginPath();
        c.arc(ast.position.x, ast.position.y, ast.radius, 0, Math.PI * 2, true);
        c.closePath();
        _results.push(c.fill());
      }
      return _results;
    };
    updateBodies = function(list, dt) {
      var body, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        body = list[_i];
        body.position.x += body.velocity.x * dt;
        body.position.y += body.velocity.y * dt;
        _results.push(body.orientation += body.rotation * dt);
      }
      return _results;
    };
    resolveCollisions = function(list) {
      var b1, b2, _i, _ref, _results;
      _results = [];
      for (b1 = _i = 0, _ref = list.length; 0 <= _ref ? _i < _ref : _i > _ref; b1 = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _ref2, _results1;
          _results1 = [];
          for (b2 = _j = _ref1 = b1 + 1, _ref2 = list.length; _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; b2 = _ref1 <= _ref2 ? ++_j : --_j) {
            _results1.push(collisionCheck(list[b1], list[b2]));
          }
          return _results1;
        })());
      }
      return _results;
    };
    collisionCheck = function(body1, body2) {
      var dist;
      dist = Math.sqrt(Math.pow(body1.position.x - body2.position.x, 2) + Math.pow(body1.position.y - body2.position.y, 2));
      if (dist < (body1.radius + body2.radius)) {
        return bounce(body1, body2, dist, damping);
      }
    };
    bounce = function(body1, body2, dist, damping) {
      var ang, dir1, dir2, dx, dy, fSx1, fSx2, fSy1, fSy2, gap, gapX, gapY, mag1, mag2, massSum, nSx1, nSx2, nSy1, nSy2;
      if (damping == null) {
        damping = 1;
      }
      dx = body1.position.x - body2.position.x;
      dy = body1.position.y - body2.position.y;
      ang = Math.atan2(dy, dx);
      mag1 = Math.sqrt(body1.velocity.x * body1.velocity.x + body1.velocity.y * body1.velocity.y);
      mag2 = Math.sqrt(body2.velocity.x * body2.velocity.x + body2.velocity.y * body2.velocity.y);
      dir1 = Math.atan2(body1.velocity.y, body1.velocity.x);
      dir2 = Math.atan2(body2.velocity.y, body2.velocity.x);
      nSx1 = mag1 * Math.cos(dir1 - ang);
      nSy1 = mag1 * Math.sin(dir1 - ang);
      nSx2 = mag2 * Math.cos(dir2 - ang);
      nSy2 = mag2 * Math.sin(dir2 - ang);
      fSx1 = ((body1.mass - body2.mass) * nSx1 + (body2.mass + body2.mass) * nSx2) / (body1.mass + body2.mass);
      fSx2 = ((body1.mass + body1.mass) * nSx1 + (body2.mass - body1.mass) * nSx2) / (body1.mass + body2.mass);
      fSy1 = nSy1;
      fSy2 = nSy2;
      body1.velocity.x = Math.cos(ang) * fSx1 + Math.cos(ang + Math.PI / 2) * fSy1;
      body1.velocity.y = Math.sin(ang) * fSx1 + Math.sin(ang + Math.PI / 2) * fSy1;
      body2.velocity.x = Math.cos(ang) * fSx2 + Math.cos(ang + Math.PI / 2) * fSy2;
      body2.velocity.y = Math.sin(ang) * fSx2 + Math.sin(ang + Math.PI / 2) * fSy2;
      if (damping !== 1) {
        body1.velocity.x *= damping;
        body1.velocity.y *= damping;
        body2.velocity.x *= damping;
        body2.velocity.y *= damping;
      }
      gap = body1.r + body2.radius - dist;
      gapX = gap * Math.cos(ang);
      gapY = gap * Math.sin(ang);
      massSum = body1.mass + body2.mass;
      body1.px += gapX * body1.mass / massSum;
      body1.py += gapY * body1.mass / massSum;
      body2.px -= gapX * body2.mass / massSum;
      return body2.py -= gapY * body2.mass / massSum;
    };
    return exp;
  });

}).call(this);
